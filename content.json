{"meta":{"title":"Dongjun's Blog","subtitle":"Dongjun's Blog","description":"Dongjun's IT Blog","author":"Dongjun Kwon","url":"https://mayajuni.github.io","root":"/"},"pages":[{"title":"","date":"2019-09-24T08:22:21.252Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://mayajuni.github.io/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"KakaoTalk_Image_2019-09-16-15-41-54.png\",\"date\":1568972848713},{\"name\":\"net.png\",\"date\":1531719392013},{\"name\":\"error.png\",\"date\":1531719386914}]"},{"title":"About","date":"2018-07-15T23:50:55.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"about/index.html","permalink":"https://mayajuni.github.io/about/index.html","excerpt":"","text":"준비중에 있습니다."}],"posts":[{"title":"EosJS API 사용","slug":"EosJS-API-사용-1","date":"2018-08-01T01:32:00.000Z","updated":"2019-09-24T08:53:28.339Z","comments":true,"path":"2018/08/01/EosJS-API-사용-1/","link":"","permalink":"https://mayajuni.github.io/2018/08/01/EosJS-API-사용-1/","excerpt":"","text":"EosJS API 사용안녕하세요. 이전에 EOSJS 시작하기에서 간단하게 EOSJS를 사용하는 방법을 해봤습니다. 이번에는 EosJs에서 제공하는 api 중에 자주 쓰는 api를 소개하고 테스트 할 수 있게 진행을 하려고 합니다. api 목록을 보기를 원하시면 여기를 확인해 보시면 됩니다. 시작하기에 앞서 준비하기모든 코드를 직접 사용 해볼 수 있게 할 예정입니다. 그렇게 하기 위해서는 준비가 필요합니다. 준비 사항은 아래와 같습니다. nodeJs eosJs 위의 2개를 설치하고 javascript 파일 가장 위에 아래와 같이 넣어주세요. 1234567891011121314const Eos = require('eosjs');const config = &#123; expireInSeconds: 60, broadcast: true, debug: false, sign: true, // mainNet bp endpoint httpEndpoint: 'https://api.eosnewyork.io', // mainNet chainId chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',&#125;;const eos = Eos(config); 이렇게 넣고 나서 아래의 api 예제를 직접 코딩하고 nodeJs로 javascript를 실행하면 값이 나옵니다. Bp Endpoint마다 응답속도 혹은 신뢰도가 각각 다르게 때문에 본인에 가장 맞는 bp를 사용하기를 권장합니다. getBlock(blockNumOrId)해당 블록의 정보를 가지고 올 수 있습니다. params: param 설명 block_num_or_id 블록의 아이디나 number Code: 12345678// Promiseeos.getBlock(1).then(result =&gt; console.log(result)).catch(error =&gt; console.error(error));// callbackeos.getBlock(1, (error, result) =&gt; console.log(error, result));// Parameters objecteos.getBlock(&#123;block_num_or_id: 1&#125;).then(console.log); 결과 값: 1234567891011121314151617181920&#123; timestamp: '2018-06-08T08:08:08.500', producer: '', confirmed: 1, previous: '0000000000000000000000000000000000000000000000000000000000000000', transaction_mroot: '0000000000000000000000000000000000000000000000000000000000000000', action_mroot: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906', schedule_version: 0, new_producers: null, header_extensions: [], producer_signature: 'SIG_K1_111111111111111111111111111111111111111111111111111111111111111116uk5ne', transactions: [], block_extensions: [], id: '00000001405147477ab2f5f51cda427b638191c66d2c59aa392d5c2c98076cb0', block_num: 1, ref_block_prefix: 4126519930 &#125; 해당 블록에서 어떠한 일을 했는지 보기 위해서는 transactions를 보면 됩니다. transactions를 보기 위해 아래와 같이 한번 같이 해보시죠. 1234567891011121314[ &#123; status: 'executed', cpu_usage_us: 1170, net_usage_words: 40, trx: &#123; id: '8a29bfa66850b7d4a2b0b62173a24c5dfe4dbd7b39c211df6309d02a85374960', signatures: [Array], compression: 'none', packed_context_free_data: '', context_free_data: [], packed_trx: '9051595bad38f016a289000000000100a6823403ea3055000000572d3ccdcd0110e0a53cab294d7600000000a8ed3232dd0110e0a53cab294d76a0986af64b96bc65010000000000000004454f5300000000bb01496e74726f647563696e67204954414d204e6574776f726b2c20616e20454f532d426173656420444150502050726f6a656374206f6e20426c6f636b636861696e2047616d696e6720506c6174666f726d20666f722061205472616e73706172656e742047616d696e672045636f73797374656d2e202d2d576562736974653a2068747470733a2f2f6974616d2e67616d65732f656e202d2d54656c656772616d3a2068747470733a2f2f742e6d652f6974616d6e6574776f726b00', transaction: [Object] &#125; &#125; ] 위와 같은 값으로 주며 저기에서도 transaction를 보면 actions가 있으며 그걸 보면 이 블록에서 어떤일들을 했는지 더욱 깊게 볼 수 있습니다. getAccount(accountName)Eos계정의 정보를 가지고 올때 사용합니다. Params: Param 설명 account_name eos 계정의 이름 Code: 123456789101112// Promiseeos.getAccount('itamnetwork1') .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// callbackeos.getAccount('itamnetwork1', (error, result) =&gt; console.log(error, result));// Parameters objecteos.getAccount(&#123;account_name: 'itamnetwork1'&#125;) .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error)); 결과 값 1234567891011121314151617181920212223242526272829303132333435&#123; account_name: 'itamnetwork1', head_block_num: 8516805, head_block_time: '2018-07-30T07:34:52.500', privileged: false, last_code_update: '1970-01-01T00:00:00.000', created: '2018-07-09T02:24:58.500', core_liquid_balance: '12.6131 EOS', ram_quota: 14976, net_weight: 201000, cpu_weight: 10401000, net_limit: &#123; used: 1679786, available: 11108657, max: 12788443 &#125;, cpu_limit: &#123; used: 7950353, available: 6356380, max: 14306733 &#125;, ram_usage: 10934, permissions: [ &#123; perm_name: 'active', parent: 'owner', required_auth: [Object] &#125;, &#123; perm_name: 'owner', parent: '', required_auth: [Object] &#125; ], total_resources: &#123; owner: 'itamnetwork1', net_weight: '20.1000 EOS', cpu_weight: '1040.1000 EOS', ram_bytes: 14976 &#125;, self_delegated_bandwidth: &#123; from: 'itamnetwork1', to: 'itamnetwork1', net_weight: '0.1000 EOS', cpu_weight: '0.1000 EOS' &#125;, refund_request: null, voter_info: &#123; owner: 'itamnetwork1', proxy: '', producers: [], staked: 4000, last_vote_weight: '0.00000000000000000', proxied_vote_weight: '0.00000000000000000', is_proxy: 0 &#125; &#125; 위의 결과값중에 다 중요하지만 몇개만 설명을 하려 합니다. account_name누구나 다 알다 싶이 eos account name 입니다. ram_quota 내가 보유한 RAM 입니다. 단위는 byte입니다. net_limit 해당 계정이 가지고 있는 총 net, 사용 가능한 net, 사용한 net을 나타냅니다. 단위는 byte입니다. cpu_limit 해당 계정이 가지고 있는 총 cpu, 사용 가능한 cpu, 사용한 cpu을 나타냅니다. 단위는 us 입니다. ram_usage 해당 계정이 사용한 RAM 입니다 단위는 byte입니다. total_resources나에게 할당된 리소스의 eos를 보여줍니다. (누군가가 나에게 delegated한 것도 포함됩니다.) self_delegated_bandwidth내가 내 자신에게 delegated한 정보 입니다. voter_info 투표에 대한 정보입니다. 여기에서 눈여겨 봐야될 부분은 staked입니다. 이부분은 현재 내가 staked 한 부분인데요. 좀더 자세히 설명한다면 내가 스스로 내 자신에게 delegated한 부분과 누군가에서 delegated한 부분을 포함한 값입니다. getKeyAccounts(publicKey)public key에 해당하는 account들을 가지고 옵니다. Params: Param 설명 public_key EOS의 public key Code: 123456789101112// Promiseeos.getKeyAccounts('EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5') .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// callbackeos.getKeyAccounts('EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5', (error, result) =&gt; console.log(error, result));// Parameters objecteos.getKeyAccounts(&#123;public_key: 'EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5'&#125;) .then(console.log); 결과값: 1&#123; account_names: [ 'itamnetwork1' ] &#125; EOS의 public key 한개로 여러 account를 만들수 있습니다. 그렇게 때문에 account_name의 값이 string으로 이루어진 array 입니다. getCurrencyBalance(code, account, symbol)code의 symbol에 해당하는 Token을 가지고 옵니다. Params: Param 설명 code 컨트렉트 명 혹은 해당 컨트렉트가 있는 account명을 말합니다.ex) eosio.token, therealkarma 등등 account 조회할 EOS의 계정명 입니다. symbol Token의 symbol 입니다. 이부분은 필수값이 아닌 옵션 값입니다. Code: 123456789101112// Promiseeos.getCurrencyBalance('eosio.token', 'itamnetwork1', 'EOS') .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// callbackeos.getCurrencyBalance('eosio.token', 'itamnetwork1', 'EOS', (error, result) =&gt; console.log(error, result));// Parameters objecteos.getCurrencyBalance(&#123;account: 'itamnetwork1', code: 'eosio.token', symbol: 'EOS'&#125;) .then(console.log); 결과값: 1[ '12.6131 EOS' ] 결과 값을 보면 string형식의 array가 나옵니다. 이유는 해당 컨트렉트안에 여러 symbol을 가진 token들이 있을수 있기 때문입니다. EOS 테스트넷인 정글넷을 보면 symbol을 제외하고 eosio.token을 조회하면 2개의 token들을 볼수 있습니다. getCurrencyStats(code, symbol)symbol에 해당하는 Token의 정보를 가지고 옵니다. Params: Param 설명 code 컨트렉트 명 혹은 해당 컨트렉트가 있는 account명을 말합니다.ex) eosio.token, therealkarma 등등 symbol Token의 symbol 입니다. Code: 123456789101112// Promiseeos.getCurrencyStats('eosio.token', 'EOS') .then(result =&gt; console.log(result)) .catch(error =&gt; console.error(error));// callbackeos.getCurrencyStats('eosio.token', 'EOS', (error, result) =&gt; console.log(error, result));// Parameters objecteos.getCurrencyStats(&#123;code: 'eosio.token', symbol: 'EOS'&#125;) .then(console.log); 결과값: 1234&#123; EOS: &#123; supply: '1006148640.3388 EOS', max_supply: '10000000000.0000 EOS', issuer: 'eosio' &#125; &#125; 결과값에 대한 설명은 아래와 같습니다. supply현재 공급된 토큰의 갯수 입니다. max_supply 총 토큰의 갯수 입니다. issuer발행자 입니다. 마무리하며자주 쓰는 api들중 5개를 소개하는 시간을 가지게 되었습니다. 아직 더 많은 api들이 있고 다음 블로그에 이어서 많이 쓰는 api들에 대해서 연재할 계획입니다. 감사합니다. 해당 예제는 github에서 확인 하실 수 있습니다. 해당 게시글은 저의 블로그 혹은 itamnetwork 블로그에서 동일하게 확인 하실수 있습니다.","categories":[{"name":"eos","slug":"eos","permalink":"https://mayajuni.github.io/categories/eos/"},{"name":"eosjs","slug":"eos/eosjs","permalink":"https://mayajuni.github.io/categories/eos/eosjs/"}],"tags":[{"name":"eosjs","slug":"eosjs","permalink":"https://mayajuni.github.io/tags/eosjs/"}],"author":"Dongjun Kwon"},{"title":"eosJs 시작하기","slug":"eosJs-시작하기","date":"2018-07-16T05:19:00.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"2018/07/16/eosJs-시작하기/","link":"","permalink":"https://mayajuni.github.io/2018/07/16/eosJs-시작하기/","excerpt":"","text":"EOSJS 시작하기EOSJS란?EOS 블록체인을 javascript로 좀더 편하게 컨트롤 할 수 있게 만들어 놓은 라이브러리라고 생각하면 편하다. 살짝만 깊게 들어가면 EOS에서 제공하는(nodeos) HTTP API를 이용하게 편하게 해 놓은 거라고 말 할 수 있다. (이더리움에는 web3.js, 네오에는 neon-js) EOSJS도 EOS에서 제공하는 HTTP API를 사용하기 때문에 BP들을 잘 선택해야된다.(응답속도, 제공여부 등등) 설치설치 방법으로는 2가지가 있다. NPM을 통해서 간단하게 설치 할 수 있다. 1&gt; npm install eosjs CNS를 이용하기 123&lt;script src=\"https://cdn.jsdelivr.net/npm/eosjs@15.0.3/lib/eos.min.js\" integrity=\"sha512-QX0dPq5pyX33coEuy5x1UqKHFDeveQYMp7Sz+qOUwRL9mol4QDvViU+QAjd+k6P7QjPjrDCoyhK1kz2GDxCP9A==\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; EOS Connect EOSJS를 이용한 EOS Connect 1234const Eos = require('eosjs');// 아래와 같이 하면 localhost Testnet에 접근한다.const eos = Eos(); localhost에 EOS가 구동 되어있지 않는다면 위의 코드를 실행하면 아래와 같은 에러가 난다. (당연히 connect하는 EOS의 httpEndpoint가 틀려도 아래와 같은 에러가 나온다.) 1234567891011121314&#123; FetchError: request to http://127.0.0.1:8888/v1/chain/get_info failed, reason: connect ECONNREFUSED 127.0.0.1:8888 at ClientRequest.&lt;anonymous&gt; (/Users/mayajuni/Projects/eos-scan/node_modules/node-fetch/index.js:133:11) at ClientRequest.emit (events.js:182:13) at Socket.socketErrorListener (_http_client.js:382:9) at Socket.emit (events.js:182:13) at emitErrorNT (internal/streams/destroy.js:82:8) at emitErrorAndCloseNT (internal/streams/destroy.js:50:3) at process._tickCallback (internal/process/next_tick.js:63:19) name: 'FetchError', message: 'request to http://127.0.0.1:8888/v1/chain/get_info failed, reason: connect ECONNREFUSED 127.0.0.1:8888', type: 'system', errno: 'ECONNREFUSED', code: 'ECONNREFUSED' &#125; Mainnet connect 하기 123const Eos = require('eosjs');const eos = Eos(&#123;httpEndpoint: 'mainnet httpEndpoint'&#125;); 아마 위와 같이 connect를 시도 한다면 아래와 같은 에러 메시지가 나온다. 에러가 나더라도 getInfo는 가능하네 이걸 통해서 chainId를 확인해서 넣자. Mainnet인 경우는 aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906 이것이 공통으로 쓰는 chainId이기 때문에 넣으면 된다. 위와 같은 방법으로 connect를 하면 아래와 같이 최초 1회 get_info api를 호출한다. (처음에 이것도 모르고 매번 커넥트를 줬더니 모바일에서 데이터 사용량이 아주 높게 나온적이 있다.) 메인넷 주소는 https://api.eosnewyork.io 여기에서 확인 해 볼 수 있다. BP들마다 제공하는 정보의 양, 응답속도 등등이 다르기 때문에 확인을 해서 본인에게 가장 잘 맞는 BP를 찾는 것이 좋다.(혹은 본인이 직접 full node를 받아서 연결하는 방법도 있다.) Connect Config12345678910111213const Eos = require('eosjs');const config = &#123; chainId: null, // 32 byte (64 char) hex string keyProvider: ['PrivateKeys...'], // WIF string or array of keys.. httpEndpoint: 'http://127.0.0.1:8888', expireInSeconds: 60, broadcast: true, verbose: false, // API activity sign: true&#125;;const eos = Eos(config); 이부분의 자세한 내용은 github에 있으니 여기에서 확인하면 된다.(github-configuration) getInfo - apiEOS의 기본 네트워크 정보를 가지고 올 수 있다. 코드는 아래와 같다. 123const eos = Eos().getInfo((error, info) =&gt; &#123; console.log(error, info);&#125;); 재미 있는 것은 다른 api들은 전부 Promise를 기본으로 하는데 getInfo만 callback방식이다. 리턴된 값은 아래와 같다. 1234567891011121314151617&#123; server_version: '36a043c5', chain_id: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906', head_block_num: 5469047, last_irreversible_block_num: 5468711, last_irreversible_block_id: '00537227a657d1f4fd74de877e9ad1a3839540ece45eedeaf177b20e51b2da1b', head_block_id: '005373770504c59e992214b3056c7bdabb07c53c5a9c4785909b90fe595a119f', head_block_time: '2018-07-12T08:58:05.500', head_block_producer: 'helloeoscnbp', virtual_block_cpu_limit: 200000000, virtual_block_net_limit: 1048576000, block_cpu_limit: 199900, block_net_limit: 1048576&#125; 위에서(EOS Connect) 애기 했던 chainId를 모를 경우 getInfo를 통해서 chainId를 얻어서 쓸 수 있다. 이번 글에서는 설치, connect, getInfo만 첫 걸음이라는 생각으로 가볍게 알아보았다.","categories":[{"name":"eos","slug":"eos","permalink":"https://mayajuni.github.io/categories/eos/"},{"name":"eosjs","slug":"eos/eosjs","permalink":"https://mayajuni.github.io/categories/eos/eosjs/"}],"tags":[{"name":"eosjs","slug":"eosjs","permalink":"https://mayajuni.github.io/tags/eosjs/"},{"name":"eos","slug":"eos","permalink":"https://mayajuni.github.io/tags/eos/"},{"name":"block chain","slug":"block-chain","permalink":"https://mayajuni.github.io/tags/block-chain/"}],"author":"Dongjun Kwon"},{"title":"RethinkDB 소개","slug":"RethinkDB-시작하기","date":"2017-03-27T04:18:00.000Z","updated":"2019-09-24T08:22:21.242Z","comments":true,"path":"2017/03/27/RethinkDB-시작하기/","link":"","permalink":"https://mayajuni.github.io/2017/03/27/RethinkDB-시작하기/","excerpt":"","text":"RethinkDB란?Real-Time에 최적화된 오픈소스 데이터베이스라고한다. 그리고 확장 가능한 JSON 데이터 베이스이며, 전통적인 데이터베이스 아키텍처를 바꾸어 변경 사항을 폴링하는 대신 업데이트 된 쿼리 결과를 실시간, 지속적으로 push 할 수 있다고 한다.특징을 설명하자면 아래와 같을꺼 같다. 실시간에 최적화 되어 있다. JSON 기반의 데이터베이스이다. 업데이트가 발생 되었을 시 지속적/실시간으로 push를 해준다. 확장이 쉬운 분산 데이터베이스 실시간 웹 애플리케이션 구죽을 위한 오픈소스 데이터 베이스 웹UI 관리 콘솔을 제공한다.(서버 성능 확인, 쿼리테스트 데이터 테이블과 샤드 등등을 관리하는 도구이다.) RethinkDb와 실시간 동기화 서비스의 차이점은 무엇을까?RethinkDb는 Firebase, pubNub, pusher와 같은 실시간 API와 근본적으로 다른 3가지가 있다. 실시간 동기화 API는 클라우드 서비스이고 RethinkDB는 오픈소스 프로젝트이다. 실시간 동기화 API는 문서 동기화에만 국한되며, RethinkDB는 범용 데이터베이스 시스템이다. 테이블 조인, 하위쿼리, 지형공간 쿼리 등등을 포함한 쿼리를 실행 할 수 있다. 실시간 동기화 API는 브라우저에서 직접 액세스하도록 설계되어 있다. 이러면 기본 앱을 쉽게 실행 할 수 있지만 앱이 확장되면 유연성이 제한된다. RethinkDB는 기존 데이터베이스와 같이 응용 프로그램 서버에서 엑세스 할 수 있도록 설계되어 있다. 쉽게 말해 많은 유연성을 가지고 있다. RethinkDB와 MongoDB의 차이점은 무엇일까?RethinkDB를 살펴 보면 Mongodb의 oplog가 생각이 든다. 물론 그거 말고도 비슷한 점이 많긴 하다. 하지만 기본적으로 다른 아키텍처를 기반으로 되어 있다. 개발자는 변경상항을 폴링하는 대신 실시간으로 업데이트 된 쿼리 결과를 계속 푸쉬하도록 RethinkDB에서 할 수 있다. 예로 들어 쿼리를 본다면 아래와 같다. 1r.table('users').get('coffeemug').changes().run() 위에서 언급했지만 몽고디비의 oplog와 비교 될 수 있지만 oplog보다는 훨씬 노은 수준의 추상화를 제공한다. RethinkDB의 피드는 쿼리 계산 엔진과 완벽하게 통합되므로 원시 복제 데이터뿐만 아니라 쿼리 결과의 변경 내용을 구독 할 수 있다. 이 아키텍처는 확장 가능한 실시간 응용 프로그램을 구축하는 데 필요한 시간과 노력을 크게 줄일 수 있다. 이외에도 MongoDB에 비해 여러가지 장점을 제공한다. 테이블 조인, 하위 쿼리 및 대규모 병렬 분산 계산을 지원하는 고급 쿼리 언어다. 우아하고 강력한 연산 및 모니터링 API로 쿼리 언어와 통합되며 RethinkDB를보다 쉽게 확장 할 수 있다. 몇 번의 클릭만으로 샤드하고 복제 할 수있는 간단하고 아름다운 관리 UI 및 온라인 문서 및 쿼리 언어 제안을 제공한다. 시스템 요구 사항RethinkDB 서버는 C++로 작성되었으며, 32비트 및 64비트 리눅스 시스템과 OS X 10.7이상에서 실행 할 수 있다.최소 2기가 이상의 램을 권장하지만 업격한 하드웨어 요구 사항은 없다.(다른 블로그를 보니 램이 부족해서 몽고디비로 이전했다는 사람도 있긴했다.) 라이센스는 무엇을까?RethinkDB 서버 및 클라이언트 드라이버는 Apache License 버전 2.0 에 따라 사용이 허가됩니다 . 다음에는 간단한 설치부터 쿼리하는거까지 진행을 해보도록 하겠다. 참고사항 Rethink FAQ RethinkDB","categories":[{"name":"NoSql","slug":"NoSql","permalink":"https://mayajuni.github.io/categories/NoSql/"},{"name":"rethinkDB","slug":"NoSql/rethinkDB","permalink":"https://mayajuni.github.io/categories/NoSql/rethinkDB/"}],"tags":[{"name":"rethinkDb","slug":"rethinkDb","permalink":"https://mayajuni.github.io/tags/rethinkDb/"},{"name":"NoSql","slug":"NoSql","permalink":"https://mayajuni.github.io/tags/NoSql/"}],"author":"Dongjun Kwon"},{"title":"es2015 요약","slug":"es2015","date":"2016-12-05T05:59:02.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"2016/12/05/es2015/","link":"","permalink":"https://mayajuni.github.io/2016/12/05/es2015/","excerpt":"","text":"ES2015 ES2015는 Javascript의 버전이다. Ecma라는 단체에서 기존의 결점을 보완한 표준 자바스크립트 버전을 매년 발표한다. ES는 EcamaScript의 줄임말이다. let 블록 스코프 변수(block scoped variable)이다. var가 함수 스코프 변수 이라는 점에서 대비된다. 블록 단위안에서도 hoisting 되지 않는다. 같은 스코프에서 재선언이 불가능하다. ex: 블록 스코프 변수 / 함수 스코프 변수 예제 12345678if(true) &#123; var a = 'a'; let b = 'b'; console.log('a =&gt; ', a); // a console.log('b =&gt; ', b); // b&#125;console.log('a =&gt; ', a); // aconsole.log('b =&gt; ', b); // b is not defined hoisting 예제 123456if(true) &#123; console.log('a =&gt; ', a); // undefined console.log('b =&gt; ', b); // b is not defined var a = 'a'; let b = 'b';&#125; 같은 스코프에서 재선언 불가능 예제 1234var a = 'a'; // a = 'a'var a = 'aa'; // a = 'aa'let b = 'b'; // b = 'b'let b = 'bb'; // Identifier 'b' has already been declared const 읽기 전용 상수 객체를 할당하면 참조값이 상수에 할당되므로 객체의 프로퍼티는 변경 가능 const 또한 block scoping을 따르며 hoisting 되지 않는다. ex: 읽기 전용 예제 12const a = 'a'; // a = 'a'a = 'b' // Assignment to constant variable. 프로퍼티 변경 예제 1234const a = &#123;name: 'a'&#125;;console.log('a.name =&gt; ', a.name); // aa.name = 'b';console.log('a.name =&gt; ', a.name); // b Set - Collection Set은 유일한 값들로 구성된 Collection add한 순서대로 원소를 가지고 있다. 중복된 값은 자동 삭제된다. ex: 12345const a = new Set();a.add(1).add(2).add(1); // Set &#123;1, 2&#125;console.log('a size: ', a.size); // 2a.delete(2); // Set &#123;1&#125;a.forEach(f =&gt; console.log(f)); // 1 WeakSet - Collection weakly하게 값을 참조한다는 뜻인데 WeakSet이 갖는 객체의 참조값이 다른곳에서 참조되지 않으면 객체는 garbage collect 대상 객체 참조값만 가진다. iterable 객체가 아니다. .has(), .get(), .set(), .delete()만 지원 ex: 123456const ws = new WeakSet();const value = &#123;a: 'a'&#125;;ws.add(value).add(&#123;b: 'moon'&#125;);console.log(ws); // WeakSet &#123;Object &#123;b: \"moon\"&#125;, Object &#123;a: \"a\"&#125;&#125;/* after the garbage Collection has run */console.log(ws); // WeakSet &#123;Object &#123;a: \"a\"&#125;&#125; Map - Collection key-value로 이루어진 Collection iterable 객체 삽입한 순서대로 원소를 가진다. ex: 1234567const map = new Map();const obj = &#123;a: 2&#125;;map.set(obj, 2).set(1, 1).set(1, 2);console.log('map has 1: ', map.has(1)); // map has 1: trueconsole.log('value of 1: ', map.get(1)); // value of 1: 2map.delete(1);console.log('map has 1: ', map.has(1)); // map has 1: false WeakMap - Collection WeakSet 과 비슷한 개념으WeakMap 의 key 가 약하게 참조된다. key는 객체참조 값만을가진다. iterable 객체가 아니다. ex: 123456const ws = new WeakMap();const obj = &#123;a: 'a'&#125;;ws.set(obj, 1).set(&#123;b: 2&#125;, 2);console.log(ws); // WeakMap &#123;Object &#123;a: \"a\"&#125; =&gt; 1, Object &#123;b: 2&#125; =&gt; 2&#125;/* after the garbage Collection has run */console.log(ws); // WeakMap &#123;Object &#123;a: \"a\"&#125; =&gt; 1&#125; arrow function 보다 간결한 구문을 지닌 익명함수이다. 자기 고유의 this 를 갖지 않고, 외부 스코프의 this 를 그대로 가진다 (lexicalbinding) ex: 123const func = (x, y) =&gt; &#123; return x + y; &#125;;/* json을 리턴할 때에는 괄호를 넣어준다. */const func2 = () =&gt; (&#123; foo: 1 &#125;); class 기존모델에 단지 새롭게 추가된 구문일 뿐,전혀 새로운 객체지향 모델이 아니다. 생성자나 상속의 좀 더 간단하고 명확한 구문이 제공된다. 생성자는 constructor 로 표현된다. 클래스 바디는 중괄호 안에 두고 여기에 메소드를 function 키워드 없이 정의한다. 메소드는 prototype 프로퍼티에 추가된다. class는 프로퍼티와 메소드로 이루어져 있다. class 는 extends 구문으로 다른 class 를 상속한다. 자식 클래스에 constructor 가 없으면 부모의 그것이 자동으로 호출된다. 생성자에서 super 키워드를 통해 상속 계층을 구현한다. this 보다 먼저 사용하지 않으면 예외가 발생한다. static 키워드를 통해 정적 메소드를 만들 수 있다. 이 메소드는 클래스 prototype 프로퍼티가 아닌 클래스 자체 메소드다. (유틀리티 함수 작성에 쓰인다.) ex: 일반 예제 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); // 7.0710678118654755 상속 12345678910111213141516class Cat &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Lion extends Cat &#123; speak() &#123; super.speak(); console.log(this.name + ' roars.'); &#125;&#125;const lion = new Lion('happy');lion.speak(); Template string 백틱(Backtick)을 이용해 문자열을 만드는 새로운 방법 코드의 가독성을 높여준다. ${} 표현식을 사용하여 변수, 함수, 연산식 등을 표현 할 수 있다. ex: 12345678910111213141516const name = 'dowon';const myStr = `Hi $&#123;name&#125;. Have a great day!`;console.log(myStr); // Hi dowon. Have a great day!console.log(\"string text line 1\\n\"+\"string text line 2\");/* \"string text line 1 string text line 2\" */console.log(`string text line 1string text line 2`);/* \"string text line 1 string text line 2\" */const a = 5;const b = 10;console.log(`Fifteen is $&#123;a + b&#125; and not $&#123;2 * a + b&#125;.`); // Fifteen is 15 and not 20.const a = () =&gt; \"test\";console.log(`a: =&gt; $&#123;a()&#125;`); for~of 구문 for~in 문은 객체의 열거가능한 모든 속성에 대해 반복했다면, for ~ of 문은 컬렉션의 요소를 반복. forEach(), for in 구문과 달리, break, continue, 그리고 return 구문과 함께 사용할 수 있습니다. for~of 루프 구문은 data를 순회하기 위한 구문 배열 뿐만 아니라 Collection 객체, DOM NodeList 등등 을 다를수 있다. ex) 1234567891011121314151617181920212223242526272829303132333435for (let chr of \"12\") &#123;console.log(chr);&#125;//1//2let iterable = [10, 20, 30];for (let value of iterable) &#123; console.log(value);&#125;let iterable = new Uint8Array([0x00, 0xff]);for (let value of iterable) &#123; console.log(value);&#125;// 0// 255let iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);for (let entry of iterable) &#123; console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3]for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 Iterator Iterator 는 새로운 문법이나 built-in 이 아니라 프로토콜(약속)이다. 간단한 약속만 지키면 누구나 만들수 있다. Set Map Array 등이 Iterator 객체이다. Symbol.iterator 를 Key 로 갖는 속성이 반드시 존재해야 한다. 다음 규칙에 따라 next() 메서드를 구현한 객체를 iterator 라고 한다:12345아래의 두 속성을 가지는 객체를 리턴하며 인자가 없는 함수:1. done (boolean) - iterator 가 순회를 모두 마쳤을 경우 true - iterator 가 순회할 다음 value 가 존재할 경우 false2. value - iterator 에 의해 리턴될 값. done 이 true 일 경우 생략 가능 ex: 12345678910111213141516171819var iterable = &#123; [Symbol.iterator]() &#123; return &#123; i: 0, next() &#123; if (this.i &lt; 3) &#123; return &#123; value: this.i++, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125; &#125;; &#125;&#125;;for (var value of iterable) &#123; console.log(value);&#125;// 0// 1// 2 Rest Parameter 와 Default Parameter이건 코드로 확인하는게 가장 편하다. rest parameter 1234567891011121314151617181920// 사용법은 아래와 같다.function(a, b, ...theArgs) &#123; // ...&#125;// exfunction restParam(...arg) &#123; for(let val of arg) console.log(val);&#125;restParam(1,2,3,4,5);// es2function restParam2(first, ...arg) &#123; console.log(first); // 시작 for(let val of arg) console.log(val); // 1 // 2 // 3 // 4 // 5&#125;restParam('시작', 1,2,3,4,5); Default Parameter parameter 값이 없을 시 Default로 값을 넣어준다.123456function defaultParam(a = 'test', b = 'done') &#123; console.log(`a: $&#123;a&#125;`); console.log(`b: $&#123;b&#125;`);&#125;defaultParam();// 기타123456const obj = &#123;a:1, b:2&#125;;const &#123;a,b&#125; = obj;console.log(a,b); // 12const a = [1,2,3];const aCopy = [...a];console.log(aCopy);","categories":[{"name":"es2015","slug":"es2015","permalink":"https://mayajuni.github.io/categories/es2015/"}],"tags":[{"name":"es2015","slug":"es2015","permalink":"https://mayajuni.github.io/tags/es2015/"}]},{"title":"angular2 실무 프로젝트 회고","slug":"angular2-실무-프로젝트-회고","date":"2016-11-30T12:04:00.000Z","updated":"2019-09-24T08:22:21.242Z","comments":true,"path":"2016/11/30/angular2-실무-프로젝트-회고/","link":"","permalink":"https://mayajuni.github.io/2016/11/30/angular2-실무-프로젝트-회고/","excerpt":"","text":"이것은 내가 실무로 프로젝트 리더이였을 때 느꼈던 회고를 기록으로 남긴다. 대화형 커머스 - 총 6명Angular2 로 하는 첫 실무 프로젝트이며, 이 프로젝트는 angular2-seed 를 사용하여 진행하였습니다. 생각외로 typescript 의 진입장벽은 높지 않았고 팀원(신입도)들이 잘 받아드리고 편하게 사용했다. rxJs, redux 에 대해 팀원들을 이해시키기까지 어려웠다.(결국 이해한 팀원만 해당 기술 개발을 하고 남어지 팀원은 사용법만 익히게 하였다. 이와 같이 하니 어려움 없이 프로젝트 진행이 가능했다) Rc4 으로 시작해서 정식 버전까지 마이그레이션을 했었는데 가장 힘들었을 때가 ngModule 나올 때였다.(Rc5) ngModule 을 잘이해하고 설계를 잘해고 개발하면 아주 좋다.(이해하기 편할려면 angular1 의 모듈을 생각하면 될 듯하다.) 개발하면서 redux 를 사용하였지만 이게 꼭 필요한가에 대해서는 아직도 의문점이다.(있으면 편하긴하다) JIT 컴파일보다 AOT 컴파일이 확실히 체감을 느낄 정도로 빠르다. 무조건 필수다. Tpyescript 의 타입과 인터페이스는 정말 개발자가 놓치고 있는 부분을 잡아주며, 오류도 적게 내면서 개발속도 즉 생산성도 높혀준다.(typescript 는 정말 좋다) Control flow 기반의 코딩이 너무 익숙하다 보니 Data flow 기반의 코딩이 쉽지 않다.(우린 둘다 잘해야된다.) rxJs 를 잘 알고 이해하면 angular2 의 코드의 질이 좋아진다. zoneJs 도 공부하면 좀더 품질의 코드가 나오지만 자료가 많지 않다. 일정표 - 총 3명대화형 커머스가 우선순위에서 밀리면서 시작한 새로운 프로젝트 입니다. 일정이 길지 않아서 ionic2 를 검토하고 잘 맞는다면 그것을 통해 진행을 하자고 했습니다. 확실히 ionic2 는 하이브리드 앱에 적합하였지만 모바일웹으로 사용하기에도 무리가 없었습니다. 그에 맞혀 바로 ionic2 를 가지고 요구 사항을 분석하고 설계하여 첫 번째 angular2 프로젝트의 회고를 토대로 개발을 진행하였고 현재도 진행하고 있습니다. Ionic2 에는 라우터가 포함되어 있지 않다.(하지만 angular2 기반이기 때문에 포함 시킬 수 있다.) Router 를 썼을씨 html5 base url 을 설정해도 #가 붙는다.(ex. domail.com/#/login) Angular2-seed 보다 설정이 간편하다.(설치만 하고 따로 셋팅을 하지 않아도 된다.) Ionic2 serve 는 많이 무겁다(메모리 릭이 잘난다) 지원하는 component 가 많다. Service worker 를 사용한다.(주석 처리되어 있어서 주석만 풀면된다. 지원하지 않는 브라우저는 그냥 패스된다). 코드리뷰 - 총 6명 서로의 실력 향상에 가장 좋은 방법이다. 리뷰를 진행하는 사람의 역할이 크다.(리뷰를 하는 사람만 말하는 코드리뷰는 효과가 반감된다.) 신입들은 꼭 1 질문씩 하는 것으로 진행하였다.(가만히 있는 것은 알고 있다고 생각하여 물어보았다) 꼭 tsLint 나 jsLint 를 사용하여 코드리뷰 때 컨벤션에 대한 애기가 안나오게 해야된다.","categories":[{"name":"회고","slug":"회고","permalink":"https://mayajuni.github.io/categories/회고/"},{"name":"프로젝트","slug":"회고/프로젝트","permalink":"https://mayajuni.github.io/categories/회고/프로젝트/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://mayajuni.github.io/tags/회고/"}],"author":"Dongjun Kwon"},{"title":"nodeJs mysql (async/await를 이용한 mySql 모듈 만들기)","slug":"typescript-nodejs-mysql","date":"2016-07-11T23:53:11.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"2016/07/12/typescript-nodejs-mysql/","link":"","permalink":"https://mayajuni.github.io/2016/07/12/typescript-nodejs-mysql/","excerpt":"","text":"nodeJs를 이용하여 mysql 혹은 mariaDB 등 RDB를 사용하는 경우가 많다. es7에 제안된 async/await를 사용하여 mysql 모듈을 만들어 볼까 한다.(모듈이라고 하지만 그저 wrapping 한거다.) 기존 사용 했던 mysql 코드처음 mysql을 썼었을때 pool을 이용하여, 매번 connection을 맺고 끊어주고, 또 트랜젝션을 맺고 롤백과 commit을 해주는 코드를 썼다. 아마 대부분이 아래와 같을 것이다.: 1234567891011121314151617181920const mysql = require('mysql');const DBpool = mysql.createPool(&#123; connectionLimit : 10, host : 'example.org', user : 'bob', password : 'secret', database : 'my_db'&#125;);const get = id =&gt; &#123; DBpool.getConnection((err, con) =&gt; &#123; if (err) &#123; throw err; &#125; con.query('select * from user where id= ?', [id], (err, data) =&gt; &#123; con.release(); ... &#125;); &#125;);&#125; 트랜젝션을 사용: 12345678910111213141516171819202122232425262728293031323334353637383940414243// pool은 생략const insert = id =&gt; &#123; DBpool.getConnection((err, con) =&gt; &#123; if (err) &#123; throw err; &#125; con.beginTransaction(err =&gt; &#123; if (err) &#123; con.release(); throw err; &#125; con.query('select * from user where id = ?', [id], (err, data) =&gt; &#123; if(err) &#123; return con.rollback(() =&gt; &#123; con.release(); throw err; &#125;); &#125; con.query('insert into user (name) values (?)', [data[0].name], (err, data) =&gt; &#123; if(err) &#123; return con.rollback(() =&gt; &#123; con.release(); throw err; &#125;); &#125; con.commit((err) =&gt; &#123; if (err) &#123; return con.rollback(() =&gt; &#123; con.release(); throw err; &#125;); &#125; return con.release(); &#125;); &#125;); ... &#125;); &#125;); &#125;);&#125; 이렇게 되면 매번 db 작업을 할때마다 connection 맺어주고 끊어주는 중복된 코드를 작성해야되며, 트렌젝션을 사용할 때는 콜백헬과 좀더 더 긴 코드를 매번 처리해줘야된다. 필자는 이렇게 하는 것이 너무나도 마음에 안들었고 매번 중복된 코드를 쓰는게 너무너무 귀찮아서 아래와 같이 만들어서 사용했다. 1. 시작하기async/await를 사용하기 위해서는 Babel을 사용하거나 Typescript 같은 것을 사용해야된다. 필자는 Typescript를 사용하기 때문에 Typescript로 진행 하겠다. 기본 설정: NodeJs 설치 Typescript 설치 Typings 설치 자세한 설정은 Typescript + ExpressJs 시작하기를 참고하여 진행하면 된다. 2. promise-mysqlasync/await는 전에 ExpressJs Error에서 설명 했듯이 모든 리턴은 promise로 받아야된다. 그래서 기존 mysql은 callback 기반이기 때문에 사용하지 못하고 npm에 있는 promise-mysql 모듈을 사용한다. 1npm install --save promise-mysql promise-mysql모듈은 typings에 없기 때문에 설치를 하지 않고 진행한다. 3. Module 만들기기존에는 모든 함수에 connection 맺고 끊는 혹은 콜백하고 커밋하는 코드를 넣어줬다. 이제 그부분을 분리하여, 모듈로 만들 것이다. 1) connection내가 생각하는 순서는 다음과 같다.: function을 받는다. 받은 function의 paramter들을 “…args”를 사용하여 args에 담는다. connection을 맺고 connection 객체를 생성한다. 받은 function을 connection객체와 함께 기존 paramter(args)를 넘겨주어 실행 시킨다. catch를 통해 error가 있을시 connection을 닫아주고 throw error을 해준다. error가 없을시에는 connection을 닫아주고 실행된 function을 값을 넘겨준다. 위와 같이 생각을 했으면, 아마 아래와 같은 코드가 나올 것이다. 123456789101112131415161718192021222324252627/** * 기존 import 하는 방식이 아닌 이유는 promise-mysql은 * 정의 파일(typings)이 없기 때문에 아래와 같이 쓴다. */const promiseMysql = require('promise-mysql');const pool = promiseMysql.createPool(&#123; connectionLimit : 10, host: 'example.org', user: 'bob', password: 'secret', database: 'my_db'&#125;);export const connect = fn =&gt; async (...args) =&gt; &#123; /* DB 커넥션을 한다. */ let con: any = await pool.getConnection(); /* 로직에 con과 args(넘겨받은 paramter)를 넘겨준다. */ const result = await fn(con, ...args).catch(error =&gt; &#123; /* 에러시 con을 닫아준다. */ con.connection.release(); throw error; &#125;); /* con을 닫아준다. */ con.connection.release(); return result;&#125;; 2) 트렌젝션 모듈트렌젝션 모듈도 위의 connection모듈과 크게 다르지 않을것이다. 그저 롤백과 커밋이 들어간것이다. function을 받는다. 받은 function의 paramter들을 “…args”를 사용하여 args에 담는다. connection을 맺고 connection 객체를 생성한다. 트렌젝션을 시작하는 코드를 넣는다. 받은 function을 connection객체와 함께 기존 paramter(args)를 넘겨주어 실행 시킨다. catch를 통해 error가 있을시 rollback과 connection을 닫아주고 throw error을 해준다. error가 없을시에는 commit과 connection을 닫아주고 실행된 function을 값을 넘겨준다. 위와 같이 생각을 했으면, 아마 아래와 같은 코드가 나올 것이다. 1234567891011121314151617181920// pool 생략export const transaction = fn =&gt; async (...args) =&gt; &#123; /* DB 커넥션을 한다. */ const con: any = await pool.getConnection(); /* 트렌젝션 시작 */ await con.connection.beginTransaction(); /* 비지니스 로직에 con을 넘겨준다. */ const result = await fn(con, ...args).catch(async (error) =&gt; &#123; /* rollback을 진행한다. */ await con.rollback(); /* 에러시 con을 닫아준다. */ con.connection.release(); throw error; &#125;); /* commit을 해준다. */ await con.commit(); /* con을 닫아준다. */ con.connection.release(); return result;&#125; 위와 같이 만든 모듈을 하나로 합치고 mysql모듈이라고 명칭하면 아래와 같다. mysql.ts12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 기존 import 하는 방식이 아닌 이유는 promise-mysql은 * 정의 파일(typings)이 없기 때문에 아래와 같이 쓴다. */const promiseMysql = require('promise-mysql');import * as dotenv from 'dotenv';dotenv.config(&#123; silent: true, path: '.env'&#125;);const pool = promiseMysql.createPool(&#123; connectionLimit : 10, host: process.env.MYSQL_HOST, user: process.env.MYSQL_USER, password: process.env.MYSQL_PASSWORD, database: process.env.MYSQL_DB&#125;);export module mysql &#123; export const connect = fn =&gt; async (...args) =&gt; &#123; /* DB 커넥션을 한다. */ const con: any = await pool.getConnection(); /* 로직에 con과 args(넘겨받은 paramter)를 넘겨준다. */ const result = await fn(con, ...args).catch(error =&gt; &#123; /* 에러시 con을 닫아준다. */ con.connection.release(); throw error; &#125;); /* con을 닫아준다. */ con.connection.release(); return result; &#125;; export const transaction = fn =&gt; async (...args) =&gt; &#123; /* DB 커넥션을 한다. */ const con: any = await pool.getConnection(); /* 트렌젝션 시작 */ await con.connection.beginTransaction(); /* 비지니스 로직에 con을 넘겨준다. */ const result = await fn(con, ...args).catch(async (error) =&gt; &#123; /* rollback을 진행한다. */ await con.rollback(); /* 에러시 con을 닫아준다. */ con.connection.release(); throw error; &#125;); /* commit을 해준다. */ await con.commit(); /* con을 닫아준다. */ con.connection.release(); return result; &#125;&#125; 이렇게 하면 mysql 모듈이 완성이다. 4. 사용법일반 connection 사용: 1234/* 위에 만든 mysql 모듈이다. */import &#123;mysql&#125; from \"mysql\"const get = mysql.connect((con: any, id: string) =&gt; con.query('select * from user', [id])); 너무 간단하게 한줄로 끝내버렸다. 물론 단순 select한 값을 리턴했기 때문에 위와 같이 한줄로 나올수 있는 것이다. 만약 다른 비지니스 로직이 있다고 하면 아래와 같다. 12345678910/* 위에 만든 mysql 모듈이다. */import &#123;mysql&#125; from \"mysql\"const get = mysql.connect(async (con: any, id: string) =&gt; &#123; const result = await con.query('select * from user', [id]); // ...비지니스로직... return result &#125;); 굳이 동기로 할 필요 없을시에는 async를 빼도 된다. 트랜젝션을 사용: 123456789/* 위에 만든 mysql 모듈이다. */import &#123;mysql&#125; from \"mysql\"const insert = mysql.transaction(async (con: any, id: string) =&gt; &#123; const user = await con.query('select * from user where id = ?', [id]); await con.query('insert into user (name) values (?)', [user[0].name]); /* 리턴할 값이 없을시 그냥 return만 써도 된다. */ return user;&#125;); 트랜젝션을 사용하는 코드는 더욱더 짧아진 코드량을 볼 수 있다. 이 모듈에 대한 예제를 github에 올렸다. 한번 보면 좀더 이해하기 편할 것이다. 도움이 되었다면 위의 별도 한번 눌러 주는 센스! 반말로 블로그를 작성하였는데 이해해주시기 바랍니다. 문의 및 수정 사항은 댓글이나 mayajuni10@gmail.com으로 이메일 보내주시기 바랍니다.","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://mayajuni.github.io/categories/Typescript/"},{"name":"nodeJs","slug":"Typescript/nodeJs","permalink":"https://mayajuni.github.io/categories/Typescript/nodeJs/"}],"tags":[{"name":"expressjs","slug":"expressjs","permalink":"https://mayajuni.github.io/tags/expressjs/"},{"name":"typescript","slug":"typescript","permalink":"https://mayajuni.github.io/tags/typescript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mayajuni.github.io/tags/nodejs/"}]},{"title":"ExpressJs Error","slug":"expressJs-error","date":"2016-07-04T00:25:35.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"2016/07/04/expressJs-error/","link":"","permalink":"https://mayajuni.github.io/2016/07/04/expressJs-error/","excerpt":"","text":"저번 포스트에서는 서버 구동에 대해서 포스팅했다. 이번에는 Error 처리에 대해 포스팅 하겠다. 기본적인 에러처리123456app.get('/', (req, res) =&gt; &#123; throw new Error('에러 발생')&#125;)app.use((err, req, res, next) =&gt; &#123; console.log(err.message)&#125;) 위와 같이 처리를 하면 큰 문제가 생긴다. 아래와 같이 callback을 받아 error 처리를 할 시 절대로 에러를 잡지 못한다. 123456789app.get('/', (req, res) =&gt; &#123; callback(error =&gt; &#123; throw new Error('에러 발생') &#125;);&#125;)app.use((err, req, res, next) =&gt; &#123; console.log(err.message)&#125;) 그래서 하는 방식이 next를 통한 에러를 전달하는 방식이다. 123456789101112app.get('/', (req, res, next) =&gt; &#123; callback(error =&gt; &#123; if(error) return next(error); callback2(error =&gt; &#123; if(error) return next(error); &#125;); &#125;);&#125;)app.use((err, req, res, next) =&gt; &#123; console.log(err.message)&#125;) 이렇게 처리시 2가지의 문제점을 가지고 있다. 로직 및 모든 부분에 Error 처리를 해줘야 한다. (이거 의외로 되게 유지보수하기 힘들고, 귀찮은 작업이다. 깜빡 한번하면 그냥 죽어버린다.) 내가 Error 처리를 하지 못하는 부분에서는 Error처리를 할 수 없다.(모듈 안에서 에러가 났던가, 기타 등등) 위와 같은 문제 때문에 필자는 node-domain-middleware 미들웨어를 사용하여 에러처리를 했다.(편하고 좋았다.) 하지만 expressJs의 성능우수 사례를 보면 도메인 사용을 권장하지 않고 더이상 사용되지 않는 모듈이라고 되어 있다. 프로미스를 이용한 에러 처리es2015에 있는 Promise를 이용하여 Error 처리 하는 방식이다. 12345678910111213app.get('/', (req, res, next) =&gt; &#123; callback() .then(_ =&gt; &#123; // 로직1 &#125;) .then(_ =&gt; &#123; // 로직2 &#125;) .catch(next);&#125;)app.use((err, req, res, next) =&gt; &#123; console.log(err.message)&#125;) 위와 같이 하면 catch를 통해 promise로 처리하는 부분의 모든 error를 처리 할 수 있다. 위에 단점으로 적었던 2가지 전부를 해결 할 수 있다. 나의 생각 일 수 있지만 코드도 좀더 간결해 보인다(아닐수도 있다.)하지만 여기서 코드를 좀더 간결하게 해보도록 하겠다. es7 스팩인 async/await를 이용할 것이다. async/await 이용한 에러 처리 async/await가 다소 생소 할 수 있다. 비동기 코드를 동기화 간편하게 해주는 것이다. es7에 제안된 스팩이며, 자세한 내용은 이곳을 보자. 구글 검색해도 많이 나온다. async/await 사용하기 위해서는 Babel 혹은 typescript 등을 사용해야된다. 필자는 typescript를 사용한다. 처음에는 우선 아래와 같이 (req, res, next) 부분을 감싸도록 하겠다. 1const wrap = fn =&gt; (...args) =&gt; fn(...args).catch(args[2]); “…args”는 es2015 문법이다. 이렇게 사용하면 args안에 parameter 값들이 순차적으로 들어가게된다.wrap은 함수를 받아서 그 함수를 실행 하고 catch를 통해 error가 발생시 next(error)을 해주는 역활이다. router에서는 기본적으로 paramter를 req, res, next를 주기 때문에 args[2]는 next 이다. 이걸 풀어서 아래와 같이 할 수 있다. 1const wrap = fn =&gt; (req, res, next) =&gt; fn(req, res, next).catch(next); 만든 wrap을 아래와 같이 한다. 123456789app.get('/', wrap(async (req, res, next) =&gt; &#123; let data = await callback(); let data2 = await 로직1(); /* 리턴 값이 없음 아래와 같이 써도 된다. */ await 로직2();&#125;))app.use((err, req, res, next) =&gt; &#123; console.log(err.message)&#125;) 코드를 보면 짐작하시겠지만 async/await를 통해 비동기 로직을 동기식으로 간편하게 로직처리 한다. 여기에도 유의점이 있다. 이것을 사용하기 위해서는 return promise 이어야된다. 단순 callback에 대한 처리를 할 수 없다. 하지만 많은 모듈 혹은 미들웨어가 promise를 제공(?)하기 때문에 사용하기에는 불편함이 없다.(기존 로직은 async/await로 처리하면되며, mongoose나 mysql 같은경우 이미 promise를 사용 할 수 있어 큰 불편이 없다.) 결론직접 이렇게 하고 사용을 하면 생산성이 확실히 빨라진다. 코드도 짧아지고 가독성도 좋아 진다. 이렇게 한번 쓰기 시작하면서 모든 노드 프로젝트는 이 방식으로 개발하고 있다. 필자는 이 방식(방법)을 추천한다. 참고 Asynchronous Error Handling in Express with Promises, Generators and ES7 프로덕션 우수 사례: 성능 및 신뢰성 반말로 블로그를 작성하였는데 이해해주시기 바랍니다. 문의 및 수정 사항은 댓글이나 mayajuni10@gmail.com으로 이메일 보내주시기 바랍니다.","categories":[{"name":"ExpressJs","slug":"ExpressJs","permalink":"https://mayajuni.github.io/categories/ExpressJs/"}],"tags":[{"name":"expressjs","slug":"expressjs","permalink":"https://mayajuni.github.io/tags/expressjs/"},{"name":"router","slug":"router","permalink":"https://mayajuni.github.io/tags/router/"}]},{"title":"Typescript + ExpressJs 시작하기","slug":"typescript-express","date":"2016-06-30T00:07:00.000Z","updated":"2019-09-24T08:22:21.252Z","comments":true,"path":"2016/06/30/typescript-express/","link":"","permalink":"https://mayajuni.github.io/2016/06/30/typescript-express/","excerpt":"","text":"최근 Angular2.0 을 스터디 하면 Typescript를 알게 되었다. 사용하면서 모든 javascript에 적용을 시키면 정말 편할꺼 같아서 개인적으로 Restful Api 서버를 만들어 보고, 그걸을 토대로 기록을 남긴다. 시작하기 및 설정시작하기 전에 먼저 설치를 해야된다. NodeJs 6버젼 이상을 추천한다.(es2015지원이 빵빵하다!) Typescript NodeJs는 해당 홈페이지 들어가서 다운로드를 받고 설치하면 문제 없지 진행 할 수 있다.Typescript 설치는 터미널을 열고 아래와 같이 npm으로 간편하게 설치가 가능하다. 1npm install -g typescript 1. 프로젝트 설정123mkdir myappcd myappnpm init npm init을 했을시 package.json을 생성시켜주지만 직접 파일로 만들어도 된다. package.json : 필요한 노드 모듈을 정의하고 프로젝트 설명이 기록되어 있다. 또한 npm 실행 script도 사용할수 있다. package.json1234567891011&#123; \"name\": \"myapp\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 초기 셋팅을 하면 위와 같이 된다. 2. expressJs 설치1npm install --save express 위와 같이 express 설치를 하면 package.json에 아래와 같이 추가가 된다. 123\"dependencies\": &#123; \"express\": \"^4.14.0\" &#125; 3. typings typings : 타입스크립트에서 사용되는 모듈 혹은 라이브러리 등등의 정의가 있는 파일이다.(쉽게 말해 자동완성 기능을 해준다.) 기능과 사용법 자세한 설명은 Typings에서 보자 설치와 설정은 아래와 같다. 12npm install -g typingstypings init typings init을 하면 typings.json이 생성된다. 여기에 우리가 설치한 Definition File들이 기록된다. NodeJs를 통해 사용되는 모듈뿐만 아니라 그 이외의 수많은 Definition이 있기 때문에 검색 후 설치하는 것을 권장한다. typings search [모듈이름] 으로 찾을 수 있으며, typings install로 설치가 가능하다. typings.json이 만들어졌으면, 우리가 사용한 모듈이랑 노드에 대해 설치를 하자. 12typings install env~node --save --globaltypings install dt~express --save --global 위의 문법은 Typings에 가면 설명나와 있다. 아마 위에 2개만 설치하고 타입스크립트 컴파일을 하면 에러가 떨어질 것이다. 이유는 express 정의 파일안에 serve-static, express-serve-static-core 파일을 import 하는 부분이 있다. 또 serve-static 안에 mime라는 정의를 임포트 하기 때문에 같이 설치한다. 123typings install dt~serve-static --save --globaltypings install dt~express-serve-static-core --save --globaltypings install dt~mime --save --global 설치가 완료 되면 typings.json을 보면 아래와 같이 되어 있다. 1234567891011&#123; &quot;name&quot;: &quot;myapp&quot;, &quot;dependencies&quot;: &#123;&#125;, &quot;globalDependencies&quot;: &#123; &quot;express&quot;: &quot;registry:dt/express#4.0.0+20160317120654&quot;, &quot;express-serve-static-core&quot;: &quot;registry:dt/express-serve-static-core#0.0.0+20160625155614&quot;, &quot;node&quot;: &quot;registry:env/node#6.0.0+20160622202520&quot;, &quot;mime&quot;: &quot;registry:dt/mime#0.0.0+20160316155526&quot;, &quot;serve-static&quot;: &quot;registry:dt/serve-static#0.0.0+20160606155157&quot; &#125;&#125; 먼저 파일을 만들고 위와 같이 작성후 typings install로 한꺼번에 설치가 가능하다. 모든 모듈, 라이브러리 등등에 정의 파일이 존재하지 않는다. 그래서 정의 파일을 사용하지 않아도 오류 없이 사용이 가능하다.const redisStore = require(&quot;connect-redis&quot;); 이와 같이 선언하면 정의 파일 없이도 에러 없이 사용 가능하다. 4. typescript 설정typescript를 사용하면 tsconfig.json라는 파일을 만들어서 설정을 진행 할 수 있다. 자세한 설명은 공식홈페이지에서 확인 할 수 있다. tsconfig.json12345678910111213141516&#123; \"compilerOptions\": &#123; \"target\": \"es6\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"sourceMap\": true, \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"removeComments\": false, \"noImplicitAny\": false &#125;, \"exclude\": [ \"typings\", \"node_modules\" ]&#125; 위의 내용으로 파일을 만든다. 이제 거의 완성이 되었다. 이렇게 되면 아래와 같은 구조가 된다.(하위 폴더는 생략) 12345├── node_modules├── typings├── package.json├── typings.json└── tsconfig.json 코딩 시작여기까지 오셨으면 설치 및 설정까지 완료된 것이다. 이제부턴 코드를 작성하겠다.es2015를 기반으로 사용할것이며, 기본적으로 es2015를 공부하면 좀더 좋다. 물론 es5로 코딩도 가능하다.post, get, delete, put 메소드를 사용하여 {result : Hello world}를 리턴을 목표로 한다 1. 테스트 코드 만들기우리가 만든 예제가 잘 돌아가는지 테스트를 하기 위해 mocha를 이용하여 테스트 코드를 만든다. 테스트 코드에 대해서는 설명을 하진 않겠다. 123456npm install -g mochanpm install --save-dev shouldnpm install --save-dev supertesttypings install dt~mocha --save --globaltypings install dt~should --save --global 위에 것들을 다 설치하면 바로 test 폴더를 만들고 그안에 app.spec.ts 파일을 만든다. ./test/app.spec.ts123456789101112131415161718192021222324252627282930313233343536373839const request = require('supertest');require('should');const server: any = request.agent('http://localhost:3000');describe('테스트 시작', () =&gt; &#123; it('GET', done =&gt; server.get('/').expect(200).expect(\"Content-type\",/json/) .end((err, res) =&gt; &#123; if(err) throw err; res.body.should.be.a.Object(); res.body.should.have.property('result'); res.body.result.should.equal('Hello World'); done(); &#125;)); it('POST', done =&gt; server.post('/').expect(200).expect(\"Content-type\",/json/) .end((err, res) =&gt; &#123; if(err) throw err; res.body.should.be.a.Object(); res.body.should.have.property('result'); res.body.result.should.equal('Hello World'); done(); &#125;)); it('DELETE', done =&gt; server.delete('/').expect(200).expect(\"Content-type\",/json/) .end((err, res) =&gt; &#123; if(err) throw err; res.body.should.be.a.Object(); res.body.should.have.property('result'); res.body.result.should.equal('Hello World'); done(); &#125;)); it('PUT', done =&gt; server.put('/').expect(200).expect(\"Content-type\",/json/) .end((err, res) =&gt; &#123; if(err) throw err; res.body.should.be.a.Object(); res.body.should.have.property('result'); res.body.result.should.equal('Hello World'); done(); &#125;));&#125;); 이제 테스트 코드도 만들었겠다. 슬슬 본격적인 코딩에 들어가겠다. 2. app.ts서버에 대한 설정을 하는 역활을 한다. 이 글에서는 간단하게 router랑 기본 설정말 할것이며, 이후 logging, db(mongo,mysql etc)설정, session(redis, cookie)등의 설정은 다루지 않겠다. 완성까지는 아니지만 express + typescript + mongodb 를 활용하여 만든 github를보면 알 수 있다. 그안에 logging부터 restapi 테스트까지 전부 있다. 코딩하는 방법은 여러가지가 있겠지만 es2015의 Class를 사용하겠다. app.ts12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import * as express from \"express\";export class Server &#123; /* app에 대한 타입 설정 */ public app: express.Application; constructor() &#123; /* express 설정을 위한 express 선언 */ this.app = express(); /* 라우터 */ this.router(); /* Not Foud */ this.app.use((req: express.Request, res: express.Response, next: Function) =&gt; &#123; /** * Error이라는 정의가 있지만 Error에는 status라는 정의가 없어서 any 설정 * (아마 typescript로 개발하다보면 any를 많이 쓰게된다) */ const err: any = new Error('not_found'); err.status = 404; next(err); &#125;); /* 에러 처리 */ this.app.use((err: any, req: express.Request, res: express.Response) =&gt; &#123; err.status = err.status || 500; console.error(`error on requst $&#123;req.method&#125; | $&#123;req.url&#125; | $&#123;err.status&#125;`); console.error(err.stack || `$&#123;err.message&#125;`); err.message = err.status == 500 ? 'Something bad happened.' : err.message; res.status(err.status).send(err.message); &#125;); &#125; private router() &#123; /** * 에러 처리를 좀더 쉽게 하기 위해서 한번 감싸준다. * es7에 제안된 async await를 사용하여 에러처리시 catch가 되기 편하게 해준 방식이다. * http://expressjs.com/ko/advanced/best-practice-performance.html#section-10 을 참고하면 좋다. */ const wrap = fn =&gt; (req, res, next) =&gt; fn(req, res, next).catch(next); //get router const router: express.Router = express.Router(); //get router.get(\"/\", wrap(async (req, res) =&gt; &#123; res.status(200).json(&#123;result: \"Hello World\"&#125;) &#125;)); //post router.post(\"/\", wrap(async (req, res) =&gt; &#123; res.status(200).json(&#123;result: \"Hello World\"&#125;) &#125;)); //put router.put(\"/\", wrap(async (req, res) =&gt; &#123; res.status(200).json(&#123;result: \"Hello World\"&#125;) &#125;)); //delete router.delete(\"/\", wrap(async (req, res) =&gt; &#123; res.status(200).json(&#123;result: \"Hello World\"&#125;) &#125;)); this.app.use(router); &#125;&#125; 위의 라우터 부분은 추후 한번 더 블로깅 하겠다. 자세하게 보고 싶으면 expressJs 성능 우수 사례의 올바른 예외처리(프로미스 사용)를 참고하면 된다. 3. server.tsapp.ts에 설정된 내용을 가지고 서버를 만들고 스타트 하는 역활을 한다. 물론 app.ts에서 해도 되지만 확정성을 고려하여 따로 분리한다. server.ts12345678910111213import &#123;Server&#125; from './app';import * as express from \"express\";/* 따로 설정하지 않았으면 3000 port를 사용한다. */const port: number = process.env.PORT || 3000;const app: express.Application = new Server().app;app.set('port', port);app.listen(app.get('port'), () =&gt; &#123; console.log('Express server listening on port ' + port);&#125;).on('error', err =&gt; &#123; console.error(err);&#125;); 4. server run타입 스크립트는 한번 컴파일을 하지 않으면 js 파일이 생성되지 않는다 그렇게 때문에 꼭 컴파일을 해야된다. 1tsc --p tsconfig.json 이렇게 하면 ts파일 이외의 js 파일과 js.map 파일이 생성된다. ts 파일이 위치한 곳에 생성되기 때문에 안좋아 보일수 있다. gulp나 grunt를 사용하면 해결 할 수 있다. 1node server 위와 같이 하면 서버가 구동된다. 구동 까지 완료 되었으면, 처음에 만든 테스트를 실행 하여, 제대로 되는지 확인한다. 1mocha mocha만 치면 프로젝트의 test폴더 안에 있는 모든 테스트 파일을 구동한다.이제 결과는 아래와 같다. 물론 웹으로 요청 한 것도 볼 수 있다. 마지막으로 package.json에 script 추가한다. package.json123456789101112131415161718192021&#123; \"name\": \"myapp\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"npm run tsc &amp; mocha\", \"start\": \"npm run tsc &amp;&amp; node server\", \"tsc\": \"tsc --p tsconfig.json\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.14.0\" &#125;, \"devDependencies\": &#123; \"mocha\": \"^2.5.3\", \"should\": \"^9.0.2\", \"supertest\": \"^1.2.0\" &#125;&#125; 아주 기본적인 구동 및 테스트만 했다.언제든 궁금한 사항이나 버그, 오류가 있을 시 mayajuni10@gmail.com으로 이메일 주시거나 혹은 아래의 댓글로 남겨주시면 수정 및 최대한 아는 범위에서 답변 하겠다. 테스트로 만든 예제 또한 github에 공개되어 있어 볼수 있다. 반말로 블로그를 작성하였는데 이해해주시기 바랍니다.","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://mayajuni.github.io/categories/Typescript/"},{"name":"nodeJs","slug":"Typescript/nodeJs","permalink":"https://mayajuni.github.io/categories/Typescript/nodeJs/"}],"tags":[{"name":"expressjs","slug":"expressjs","permalink":"https://mayajuni.github.io/tags/expressjs/"},{"name":"typescript","slug":"typescript","permalink":"https://mayajuni.github.io/tags/typescript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mayajuni.github.io/tags/nodejs/"}]}]}